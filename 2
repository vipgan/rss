import asyncio
import aiohttp
import logging
import re
import os
import json
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv
from feedparser import parse
from telegram import Bot
from telegram.error import BadRequest
from urllib.parse import quote  # 新增URL编码库
from tencentcloud.common import credential
from tencentcloud.common.profile.client_profile import ClientProfile
from tencentcloud.common.profile.http_profile import HttpProfile
from tencentcloud.tmt.v20180321 import tmt_client, models

# 加载环境变量文件
load_dotenv()

# 配置基础路径
BASE_DIR = Path(__file__).resolve().parent
STATUS_FILE = BASE_DIR / "rss.json"  # 存储处理状态的文件

# 配置日志记录
logging.basicConfig(
    filename=BASE_DIR / "rss.log",
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    encoding="utf-8"
)

# RSS源配置
RSS_FEEDS = [
    'https://feeds.bbci.co.uk/news/world/rss.xml', # bbc
  #  'https://www3.nhk.or.jp/rss/news/cat6.xml',  # nhk
  #  'http://www3.nhk.or.jp/rss/news/cat5.xml',  # nhk金融
  #  'https://www.cnbc.com/id/100003114/device/rss/rss.html', # CNBC
  #  'https://feeds.a.dj.com/rss/RSSWorldNews.xml', # 华尔街日报
  #  'https://www.aljazeera.com/xml/rss/all.xml',# 半岛电视台
  #  'https://www3.nhk.or.jp/rss/news/cat5.xml',# NHK 商业
  #  'https://www.ft.com/?format=rss', # 金融时报
  #  'http://rss.cnn.com/rss/edition.rss', # cnn

]
#主题+内容+预览
THIRD_RSS_FEEDS = [
    'https://36kr.com/feed-newsflash',
    'https://rss.owo.nz/10jqka/realtimenews',
  #  'https://rss.penggan.us.kg/rss/7b7190c84ada52e7a89e2901ea71ce41_chinese_simplified',
    'https://rss.penggan.us.kg/rss/7b0c2fb839915016a94424c9ebd6d7cb_chinese_simplified',
    'https://rss.penggan.us.kg/rss/57fac0d19e56587f9264b3a0485b46e3_chinese_simplified',
  #  'https://rss.penggan.us.kg/rss/4734eed5ffb55689bfe8ebc4f55e63bd_chinese_simplified',
]
 # 主题+预览
FOURTH_RSS_FEEDS = [
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCvijahEyGtvMpmMHBu4FS2w', # 零度解说
    'https://www.youtube.com/feeds/videos.xml?channel_id=UC96OvMh0Mb_3NmuE8Dpu7Gg', # 搞机零距离
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCQoagx4VHBw3HkAyzvKEEBA', # 科技共享
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCbCCUH8S3yhlm7__rhxR2QQ', # 不良林
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCMtXiCoKFrc2ovAGc1eywDg', # 一休
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCii04BCvYIdQvshrdNDAcww', # 悟空的日常
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCJMEiNh1HvpopPU3n9vJsMQ', # 理科男士
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCYjB6uufPeHSwuHs8wovLjg', # 中指通
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCSs4A6HYKmHA2MG_0z-F0xw', # 李永乐老师
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCZDgXi7VpKhBJxsPuZcBpgA', # 可恩KeEn
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCxukdnZiXnTFvjF5B5dvJ5w', # 甬哥侃侃侃ygkkk
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCUfT9BAofYBKUTiEVrgYGZw', # 科技分享
    'https://www.youtube.com/feeds/videos.xml?channel_id=UC51FT5EeNPiiQzatlA2RlRA', # 乌客wuke
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCDD8WJ7Il3zWBgEYBUtc9xQ', # jack stone
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCWurUlxgm7YJPPggDz9YJjw', # 一瓶奶油
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCvENMyIFurJi_SrnbnbyiZw', # 酷友社
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCmhbF9emhHa-oZPiBfcLFaQ', # WenWeekly
    'https://www.youtube.com/feeds/videos.xml?channel_id=UC3BNSKOaphlEoK4L7QTlpbA', # 中外观察
]

# Telegram配置
TELEGRAM_BOT_TOKEN = os.getenv("RSS_TWO")
RSS_TWO = os.getenv("RSS_TWO")
RSS_TOKEN = os.getenv("RSS_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "").split(",")
TENCENTCLOUD_SECRET_ID = os.getenv("TENCENTCLOUD_SECRET_ID")
TENCENTCLOUD_SECRET_KEY = os.getenv("TENCENTCLOUD_SECRET_KEY")

# 并发控制
MAX_CONCURRENT_REQUESTS = 10
semaphore = asyncio.Semaphore(MAX_CONCURRENT_REQUESTS)

# ================== Markdown处理函数 ==================
def sanitize_markdown_v2(text):
    """
    转义文本中的MarkdownV2特殊字符（用于普通文本）
    """
    md_special_chars = r'_*[]()~`>#+-=|{}.!'
    pattern = f'([{re.escape(md_special_chars)}])'
    return re.sub(pattern, r'\\\1', text)

def escape_markdown_url(url):
    """
    URL专用编码函数（将特殊字符转为百分比编码）
    """
    # 需要编码的特殊字符集合
    special_chars = {'_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!', '\\'}
    
    encoded = []
    for char in url:
        if char in special_chars:
            # 使用quote进行百分比编码
            encoded.append(quote(char, safe=''))
        else:
            encoded.append(char)
    return ''.join(encoded)

def format_link_markdown_v2(text, url):
    """
    生成安全的MarkdownV2链接格式
    现在只用来编码URL
    """
    return escape_markdown_url(url) # 只返回编码后的URL

# ================== 消息发送函数 ==================
async def send_single_message(bot, chat_id, text, disable_web_page_preview=False):
    """
    安全发送MarkdownV2格式消息（自动分片处理长消息）
    """
    try:
        MAX_MESSAGE_LENGTH = 4096  # Telegram消息长度限制
        text_bytes = text.encode('utf-8')
        
        if len(text_bytes) > MAX_MESSAGE_LENGTH:
            # 分片发送长消息
            for i in range(0, len(text), MAX_MESSAGE_LENGTH):
                await bot.send_message(
                    chat_id=chat_id,
                    text=text[i:i+MAX_MESSAGE_LENGTH],
                    parse_mode='MarkdownV2',
                    disable_web_page_preview=disable_web_page_preview
                )
        else:
            await bot.send_message(
                chat_id=chat_id,
                text=text,
                parse_mode='MarkdownV2',
                disable_web_page_preview=disable_web_page_preview
            )
    except BadRequest as e:
        logging.error(f"消息格式错误: {e} - 消息片段: {text[:200]}...")
    except Exception as e:
        logging.error(f"发送失败: {e}")

# ================== RSS处理核心 ==================
def load_status():
    """加载上次处理状态"""
    try:
        with open(STATUS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def save_status(status):
    """保存当前处理状态"""
    try:
        with open(STATUS_FILE, "w", encoding="utf-8") as f:
            json.dump(status, f, ensure_ascii=False, indent=4)
    except Exception as e:
        logging.error(f"状态保存失败: {e}")

def get_entry_identifier(entry):
    """生成条目唯一标识"""
    return entry.get('id') or entry.get('guid') or f"{entry.get('title','')}-{entry.get('link','')}"

def get_entry_timestamp(entry):
    """获取标准化时间戳"""
    for field in ['published_parsed', 'updated_parsed', 'created_parsed']:
        if hasattr(entry, field):
            return datetime(*getattr(entry, field)[:6])
    return datetime.now()

async def fetch_feed(session, feed_url):
    """获取RSS内容"""
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
    try:
        async with semaphore:
            async with session.get(feed_url, headers=headers, timeout=40) as response:
                response.raise_for_status()
                return parse(await response.read())
    except Exception as e:
        logging.error(f"抓取失败 {feed_url}: {e}")
        return None

async def auto_translate_text(text):
    """腾讯云翻译实现"""
    try:
        cred = credential.Credential(TENCENTCLOUD_SECRET_ID, TENCENTCLOUD_SECRET_KEY)
        client = tmt_client.TmtClient(cred, "na-siliconvalley")
        
        req = models.TextTranslateRequest()
        req.SourceText = text
        req.Source = "auto"
        req.Target = "zh"
        req.ProjectId = 0
        
        return client.TextTranslate(req).TargetText
    except Exception as e:
        logging.error(f"翻译失败: {e}")
        return text

# ================== 各类型Feed处理器 ==================
async def process_feed(session, feed_url, status, bot, translate=True):
    """处理常规RSS源（含自动翻译）"""
    feed_data = await fetch_feed(session, feed_url)
    if not feed_data or not feed_data.entries:
        return ""
    
    # 状态追踪逻辑
    last_status = status.get(feed_url, {})
    last_id = last_status.get('identifier')
    last_time = datetime.fromisoformat(last_status.get('timestamp')) if last_status.get('timestamp') else None
    
    sorted_entries = sorted(feed_data.entries, key=lambda x: get_entry_timestamp(x), reverse=True)
    new_entries = []
    current_latest = None
    
    for entry in sorted_entries:
        entry_time = get_entry_timestamp(entry)
        entry_id = get_entry_identifier(entry)
        
        if last_id and entry_id == last_id:
            break
        if last_time and entry_time <= last_time:
            break
        
        new_entries.append(entry)
        if not current_latest or entry_time > get_entry_timestamp(current_latest):
            current_latest = entry
    
    if not new_entries:
        return ""
    
    # 更新状态
    if current_latest:
        status[feed_url] = {
            "identifier": get_entry_identifier(current_latest),
            "timestamp": get_entry_timestamp(current_latest).isoformat()
        }
    
    # 构建消息内容
    merged_message = ""
    source_name = sanitize_markdown_v2(feed_data.feed.get('title', feed_url))
    for entry in reversed(new_entries):
        title = entry.title or "无标题"
        url = entry.link
        summary = getattr(entry, 'summary', "暂无简介")
        
        # 翻译处理
        if translate:
            title = await auto_translate_text(title)
            summary = await auto_translate_text(summary)
        
        # Markdown格式化
        safe_title = sanitize_markdown_v2(title)
        safe_summary = sanitize_markdown_v2(summary)
        link = format_link_markdown_v2(source_name, url)
        
        merged_message += f"*{safe_title}*\n{safe_summary}\n{link}\n\n"
    
    return merged_message

async def process_third_feed(session, feed_url, status, bot):
    """处理第三方短消息源"""
    feed_data = await fetch_feed(session, feed_url)
    if not feed_data or not feed_data.entries:
        return ""
    
    # ...（状态追踪逻辑与process_feed类似）...
    
    # 消息构建
    merged_message = ""
    source_name = sanitize_markdown_v2(feed_data.feed.get('title', feed_url))
    for entry in reversed(new_entries):
        title = entry.title or "无标题"
        url = entry.link
        summary = getattr(entry, 'summary', "")
        
        # 格式化处理
        safe_title = sanitize_markdown_v2(title)
        safe_summary = sanitize_markdown_v2(summary)
        link = format_link_markdown_v2(source_name, url)
        
        # 智能截断逻辑
        message_content = f"*{safe_title}*\n{safe_summary}\n{link}"
        if len(message_content.encode('utf-8')) <= 333:
            merged_message += message_content + "\n\n"
        else:
            merged_message += f"*{safe_title}*\n{link}\n\n"
    
    return merged_message

async def process_fourth_feed(session, feed_url, status, bot):
    """处理视频类源"""
    feed_data = await fetch_feed(session, feed_url)
    if not feed_data or not feed_data.entries:
        return ""
    
    # ...（状态追踪逻辑）...
    
    merged_message = ""
    source_name = sanitize_markdown_v2(feed_data.feed.get('title', feed_url))
    for entry in reversed(new_entries):
        title = entry.title or "无标题"
        url = entry.link
        
        safe_title = sanitize_markdown_v2(title)
        encoded_url = format_link_markdown_v2(url) # 使用format_link_markdown_v2来编码URL
        merged_message += f"*{safe_title}*\n{encoded_url}\n\n"
    
    return merged_message

# ================== 主程序 ==================
async def main():
    async with aiohttp.ClientSession() as session:
        # 初始化机器人实例
        main_bot = Bot(token=TELEGRAM_BOT_TOKEN)
        third_bot = Bot(token=RSS_TWO)
        fourth_bot = Bot(token=RSS_TOKEN)
        
        status = load_status()
        
        # 处理各类型源
        tasks = []
        for url in RSS_FEEDS:
            tasks.append(process_feed(session, url, status, main_bot))
        for url in THIRD_RSS_FEEDS:
            tasks.append(process_third_feed(session, url, status, third_bot))
        for url in FOURTH_RSS_FEEDS:
            tasks.append(process_fourth_feed(session, url, status, fourth_bot))
        
        # 并发执行并收集结果
        results = await asyncio.gather(*tasks)
        
        # 发送消息
        chat_id = TELEGRAM_CHAT_ID[0]
        for result, bot in zip(results[:len(RSS_FEEDS)], [main_bot]*len(RSS_FEEDS)):
            if result:
                await send_single_message(bot, chat_id, result, True)
        for result, bot in zip(results[len(RSS_FEEDS):len(RSS_FEEDS)+len(THIRD_RSS_FEEDS)], [third_bot]*len(THIRD_RSS_FEEDS)):
            if result:
                await send_single_message(bot, chat_id, result, True)
        for result, bot in zip(results[len(RSS_FEEDS)+len(THIRD_RSS_FEEDS):], [fourth_bot]*len(FOURTH_RSS_FEEDS)):
            if result:
                await send_single_message(bot, chat_id, result)
        
        save_status(status)

if __name__ == "__main__":
    asyncio.run(main())
