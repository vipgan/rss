import imaplib
import email
import logging
import os
import re
import time
from email.header import decode_header
from urlextract import URLExtract
from bs4 import BeautifulSoup
import telegram
from telegram import ParseMode
from telegram.error import TelegramError

# 配置日志记录
LOG_DIR = os.path.dirname(os.path.abspath(__file__))
LOG_FILE = os.path.join(LOG_DIR, 'email_bot.log')

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# 配置信息
CONFIG = {
    'imap_server': 'imap.qq.com',
    'imap_port': 993,
    'email': 'penggan0@qq.com',
    'password': 'hbkzbvpyojnibhid',
    'telegram_token': '7422217982:AAGcyh0Do-RzggL8i61BksdVZModB6wfHzc',
    'chat_id': '7071127210',
    'max_retries': 3,
    'send_delay': 0.5
}

# Markdown V2特殊字符转义
MD_ESCAPE_CHARS = '_*[]()~`>#+-=|{}.!'
def escape_md(text):
    return ''.join(f'\\{c}' if c in MD_ESCAPE_CHARS else c for c in text)

# 处理HTML内容
def process_html(html):
    soup = BeautifulSoup(html, 'html.parser')
    
    # 移除事件属性
    for tag in soup.find_all():
        for attr in list(tag.attrs):
            if attr.startswith('on'):
                del tag[attr]
    
    # 转换链接
    for a in soup.find_all('a'):
        href = a.get('href', '')
        text = a.get_text()
        a.replace_with(f'[{escape_md(text)}]({escape_md(href)})')
    
    # 清理其他标签
    return soup.get_text()

# 处理纯文本内容
def process_plain(text):
    extractor = URLExtract()
    urls = extractor.find_urls(text)
    for url in urls:
        text = text.replace(url, f'[{escape_md(url)}]({escape_md(url)})')
    return text

# 邮件内容解析
def parse_email(msg):
    sender = email.utils.parseaddr(msg.get('From'))[1]
    subject = decode_header(msg.get('Subject', ''))[0][0]
    if isinstance(subject, bytes):
        subject = subject.decode(errors='ignore')
    
    body = ""
    if msg.is_multipart():
        for part in msg.walk():
            content_type = part.get_content_type()
            payload = part.get_payload(decode=True)
            if not payload:
                continue
            
            charset = part.get_content_charset() or 'utf-8'
            try:
                content = payload.decode(charset, errors='replace')
            except:
                content = payload.decode('utf-8', errors='replace')
            
            if content_type == 'text/plain':
                body = process_plain(content)
                break
            elif content_type == 'text/html':
                body = process_html(content)
                body = process_plain(body)  # 处理纯文本URL
                break
    else:
        payload = msg.get_payload(decode=True)
        charset = msg.get_content_charset() or 'utf-8'
        content = payload.decode(charset, errors='replace')
        if msg.get_content_type() == 'text/plain':
            body = process_plain(content)
        else:
            body = process_html(content)
            body = process_plain(body)
    
    return sender, subject, body

# 消息分段
def split_message(text, max_len=4000):
    parts = []
    while len(text) > max_len:
        split_pos = text.rfind('\n', 0, max_len)
        if split_pos == -1:
            split_pos = max_len
        parts.append(text[:split_pos])
        text = text[split_pos:]
    parts.append(text)
    return parts

# 发送消息到Telegram
def send_to_telegram(bot, chat_id, text):
    for attempt in range(CONFIG['max_retries']):
        try:
            bot.send_message(
                chat_id=chat_id,
                text=text,
                parse_mode=ParseMode.MARKDOWN_V2,
                disable_web_page_preview=True
            )
            return True
        except TelegramError as e:
            if "Can't parse entities" in str(e):
                logger.warning("Markdown解析失败，尝试发送纯文本")
                try:
                    bot.send_message(chat_id=chat_id, text=text)
                    return True
                except TelegramError as e:
                    logger.error(f"纯文本发送失败: {e}")
            else:
                logger.error(f"发送失败: {e}")
            
            if attempt < CONFIG['max_retries'] - 1:
                sleep_time = 2 ** attempt
                logger.info(f"等待 {sleep_time} 秒后重试...")
                time.sleep(sleep_time)
    
    logger.error("超过最大重试次数")
    return False

def main():
    mail = imaplib.IMAP4_SSL(CONFIG['imap_server'], CONFIG['imap_port'])
    mail.login(CONFIG['email'], CONFIG['password'])
    mail.select('inbox')
    
    try:
        status, messages = mail.search(None, 'UNSEEN')
        if status != 'OK':
            logger.error("邮件搜索失败")
            return

        for num in messages[0].split():
            status, data = mail.fetch(num, '(RFC822)')
            if status != 'OK':
                logger.error(f"无法获取邮件 {num.decode()}")
                continue

            msg = email.message_from_bytes(data[0][1])
            sender, subject, body = parse_email(msg)
            
            # 构建消息内容
            header = f"*发件人:* {escape_md(sender)}\n*主题:* {escape_md(subject)}\n\n"
            full_message = header + escape_md(body)
            
            # 分段发送
            bot = telegram.Bot(token=CONFIG['telegram_token'])
            for part in split_message(full_message):
                if send_to_telegram(bot, CONFIG['chat_id'], part):
                    logger.info("消息部分发送成功")
                else:
                    logger.error("消息部分发送失败")
                time.sleep(CONFIG['send_delay'])
            
            # 标记为已读
            mail.store(num, '+FLAGS', '\\Seen')
            logger.info(f"邮件 {num.decode()} 处理完成")
            
    finally:
        mail.close()
        mail.logout()

if __name__ == '__main__':
    main()
    logger.info("邮件处理任务完成")