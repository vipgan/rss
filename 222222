import asyncio
import aiohttp
import logging
import re
import os
import json
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv
from feedparser import parse
from telegram import Bot
from tencentcloud.common import credential
from tencentcloud.common.profile.client_profile import ClientProfile
from tencentcloud.common.profile.http_profile import HttpProfile
from tencentcloud.tmt.v20180321 import tmt_client, models

# 加载.env 文件
load_dotenv()

# 配置绝对路径
BASE_DIR = Path(__file__).resolve().parent
SENT_ALL_PATH = BASE_DIR / "sent_rss.json"  # 合并为单个状态文件

# 配置日志
logging.basicConfig(
    filename=BASE_DIR / "rss.log",
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    encoding="utf-8"
)

# 主题+翻译内容+预览
RSS_FEEDS = [
    'https://feeds.bbci.co.uk/news/world/rss.xml', # bbc
  #  'https://www3.nhk.or.jp/rss/news/cat6.xml',  # nhk
  #  'http://www3.nhk.or.jp/rss/news/cat5.xml',  # nhk金融
  #  'https://www.cnbc.com/id/100003114/device/rss/rss.html', # CNBC
  #  'https://feeds.a.dj.com/rss/RSSWorldNews.xml', # 华尔街日报
  #  'https://www.aljazeera.com/xml/rss/all.xml',# 半岛电视台
  #  'https://www3.nhk.or.jp/rss/news/cat5.xml',# NHK 商业
  #  'https://www.ft.com/?format=rss', # 金融时报
  #  'http://rss.cnn.com/rss/edition.rss', # cnn

]
#主题+内容+预览
THIRD_RSS_FEEDS = [
    'https://36kr.com/feed-newsflash',
    'https://rss.owo.nz/10jqka/realtimenews',
    'https://rss.penggan.us.kg/rss/7b7190c84ada52e7a89e2901ea71ce41_chinese_simplified',
    'https://rss.penggan.us.kg/rss/7b0c2fb839915016a94424c9ebd6d7cb_chinese_simplified',
    'https://rss.penggan.us.kg/rss/57fac0d19e56587f9264b3a0485b46e3_chinese_simplified',
  #  'https://rss.penggan.us.kg/rss/4734eed5ffb55689bfe8ebc4f55e63bd_chinese_simplified',
]
 # 主题+预览
FOURTH_RSS_FEEDS = [
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCvijahEyGtvMpmMHBu4FS2w', # 零度解说
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UC96OvMh0Mb_3NmuE8Dpu7Gg', # 搞机零距离
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCQoagx4VHBw3HkAyzvKEEBA', # 科技共享
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCbCCUH8S3yhlm7__rhxR2QQ', # 不良林
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCMtXiCoKFrc2ovAGc1eywDg', # 一休
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCii04BCvYIdQvshrdNDAcww', # 悟空的日常
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCJMEiNh1HvpopPU3n9vJsMQ', # 理科男士
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCYjB6uufPeHSwuHs8wovLjg', # 中指通
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCSs4A6HYKmHA2MG_0z-F0xw', # 李永乐老师
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCZDgXi7VpKhBJxsPuZcBpgA', # 可恩KeEn
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCxukdnZiXnTFvjF5B5dvJ5w', # 甬哥侃侃侃ygkkk
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCUfT9BAofYBKUTiEVrgYGZw', # 科技分享
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UC51FT5EeNPiiQzatlA2RlRA', # 乌客wuke
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCDD8WJ7Il3zWBgEYBUtc9xQ', # jack stone
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCWurUlxgm7YJPPggDz9YJjw', # 一瓶奶油
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UC6-ZYliTgo4aTKcLIDUw0Ag', # 音樂花園
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCvENMyIFurJi_SrnbnbyiZw', # 酷友社
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCmhbF9emhHa-oZPiBfcLFaQ', # WenWeekly
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UC3BNSKOaphlEoK4L7QTlpbA', # 中外观察
]

# Telegram 配置
TELEGRAM_BOT_TOKEN = os.getenv("RSS_TWO")
RSS_TWO = os.getenv("RSS_TWO")
RSS_TOKEN = os.getenv("RSS_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "").split(",")

# 腾讯云翻译配置
TENCENTCLOUD_SECRET_ID = os.getenv("TENCENTCLOUD_SECRET_ID")
TENCENTCLOUD_SECRET_KEY = os.getenv("TENCENTCLOUD_SECRET_KEY")

def sanitize_markdown(text):
    text = re.sub(r'<[^>]*>', '', text)
    text = re.sub(r'[*_`|#\\[\\](){}<>]', '', text)
    return text

async def send_single_message(bot, chat_id, text, disable_web_page_preview=False):
    try:
        MAX_MESSAGE_LENGTH = 4096
        if len(text.encode('utf-8')) > MAX_MESSAGE_LENGTH:
            for i in range(0, len(text), MAX_MESSAGE_LENGTH):
                await bot.send_message(
                    chat_id=chat_id,
                    text=text[i:i + MAX_MESSAGE_LENGTH],
                    parse_mode='Markdown',
                    disable_web_page_preview=disable_web_page_preview
                )
        else:
            await bot.send_message(
                chat_id=chat_id,
                text=text,
                parse_mode='Markdown',
                disable_web_page_preview=disable_web_page_preview
            )
        logging.info(f"Message sent to chat ID {chat_id}")
    except Exception as e:
        logging.error(f"Failed to send message: {e}")

async def fetch_feed(session, feed_url):
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36'}
    try:
        async with session.get(feed_url, headers=headers, timeout=40) as response:
            response.raise_for_status()
            return parse(await response.read())
    except Exception as e:
        logging.error(f"Error fetching {feed_url}: {e}")
        return None

async def auto_translate_text(text):
    try:
        cred = credential.Credential(TENCENTCLOUD_SECRET_ID, TENCENTCLOUD_SECRET_KEY)
        clientProfile = ClientProfile(httpProfile=HttpProfile(endpoint="tmt.tencentcloudapi.com"))
        client = tmt_client.TmtClient(cred, "na-siliconvalley", clientProfile)

        req = models.TextTranslateRequest()
        req.SourceText = text
        req.Source = "auto"
        req.Target = "zh"
        req.ProjectId = 0

        return client.TextTranslate(req).TargetText
    except Exception as e:
        logging.error(f"Translation error: {e}")
        return text

def load_processed_entries():
    """加载所有源的处理状态"""
    try:
        with open(SENT_ALL_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def save_processed_entries(state):
    """保存所有源的处理状态"""
    with open(SENT_ALL_PATH, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=False, indent=4)

async def process_feed(session, feed_url, bot, chat_id, translate=True):
    state = load_processed_entries()
    last_processed_id = state.get(feed_url)
    feed_data = await fetch_feed(session, feed_url)

    if not feed_data:
        return ""

    source_name = feed_data.feed.get('title', feed_url)
    entries = sorted(feed_data.entries,
                   key=lambda e: getattr(e, 'published_parsed', datetime.min.timetuple()),
                   reverse=True)

    new_entries = []
    for entry in entries:
        entry_id = entry.get('id') or entry.get('published') or entry.link
        if entry_id == last_processed_id:
            break
        new_entries.append(entry)

    if not new_entries:
        logging.info(f"No new entries for {feed_url}")
        return ""  # 返回空字符串，表示没有新条目

    state[feed_url] = new_entries[0].get('id') or new_entries[0].link
    save_processed_entries(state)

    messages = []
    for entry in reversed(new_entries):  # 按时间顺序处理旧到新
        subject = entry.title or "*无标题*"
        url = entry.link
        summary = sanitize_markdown(getattr(entry, 'summary', "暂无简介"))

        logging.debug(f"Subject before translate: {subject}")  # 记录原始标题
        logging.debug(f"Summary before translate: {summary}")  # 记录原始摘要
        logging.debug(f"URL: {url}")  # 记录 URL

        if translate:
            subject = await auto_translate_text(subject)
            summary = await auto_translate_text(summary)

        logging.debug(f"Subject after translate: {subject}")  # 记录翻译后的标题
        logging.debug(f"Summary after translate: {summary}")  # 记录翻译后的摘要

        message = f"*{sanitize_markdown(subject)}*\n{sanitize_markdown(summary)}\n[{source_name}]({url})"

        logging.debug(f"Sending message: {message}")  # 记录最终发送的消息
        try:
            await send_single_message(bot, chat_id, message, True)
        except Exception as e:
            logging.error(f"Failed to send message for entry {subject}: {e}", exc_info=True)
            
    # 将来自此源的所有消息连接成一个消息
    combined_message = "\n\n".join(messages)
    return combined_message

async def process_third_feed(session, feed_url, bot, chat_id):
    state = load_processed_entries()
    last_processed_id = state.get(feed_url)

    feed_data = await fetch_feed(session, feed_url)
    if not feed_data:
        return ""

    source_name = feed_data.feed.get('title', feed_url)
    entries = sorted(feed_data.entries,
                   key=lambda e: getattr(e, 'published_parsed', datetime.min.timetuple()),
                   reverse=True)

    new_entries = []
    for entry in entries:
        entry_id = entry.get('id') or entry.get('published') or entry.link
        if entry_id == last_processed_id:
            break
        new_entries.append(entry)

    if not new_entries:
        logging.info(f"No new entries for {feed_url}")
        return ""

    state[feed_url] = new_entries[0].get('id') or new_entries[0].link
    save_processed_entries(state)

    messages = []
    for entry in reversed(new_entries):
        subject = entry.title or "*无标题*"
        url = entry.link
        summary = sanitize_markdown(getattr(entry, 'summary', "暂无简介"))

        total_length = len(subject.encode()) + len(summary.encode())
        if total_length <= 333:
            msg = f"*{sanitize_markdown(subject)}*\n{summary}\n[{source_name}]({url})"
        else:
            msg = f"*{sanitize_markdown(subject)}*\n[{source_name}]({url})"

        messages.append(msg)

    combined_message = "\n\n".join(messages)
    return combined_message

async def process_fourth_feed(session, feed_url, bot, chat_id):
    state = load_processed_entries()
    last_processed_id = state.get(feed_url)

    feed_data = await fetch_feed(session, feed_url)
    if not feed_data:
        return ""

    source_name = feed_data.feed.get('title', feed_url)
    entries = sorted(feed_data.entries,
                   key=lambda e: getattr(e, 'published_parsed', datetime.min.timetuple()),
                   reverse=True)

    new_entries = []
    for entry in entries:
        entry_id = entry.get('id') or entry.get('published') or entry.link
        if entry_id == last_processed_id:
            break
        new_entries.append(entry)

    if not new_entries:
        logging.info(f"No new entries for {feed_url}")
        return ""

    state[feed_url] = new_entries[0].get('id') or new_entries[0].link
    save_processed_entries(state)

    messages = []
    for entry in reversed(new_entries):
        subject = entry.title or "*无标题*"
        url = entry.link
        message = f"{source_name}\n*{sanitize_markdown(subject)}*\n{url}"
        messages.append(message)

    combined_message = "\n\n".join(messages)
    return combined_message

async def main():
    async with aiohttp.ClientSession() as session:
        bot = Bot(token=TELEGRAM_BOT_TOKEN)
        third_bot = Bot(token=RSS_TWO)
        fourth_bot = Bot(token=RSS_TOKEN)

        tasks = []

        # Ensure TELEGRAM_CHAT_ID is a list
        chat_ids = TELEGRAM_CHAT_ID if isinstance(TELEGRAM_CHAT_ID, list) else [TELEGRAM_CHAT_ID]

        feed_messages = {}  # 存储每个源的消息

        # Process RSS_FEEDS for each chat ID
        for chat_id in chat_ids:
            for url in RSS_FEEDS:
                feed_messages[url] = await process_feed(session, url, bot, chat_id)
                if feed_messages[url]:  # 如果有消息，则发送
                    await send_single_message(bot, chat_id, feed_messages[url], True)

        # Process THIRD_RSS_FEEDS for each chat ID using third_bot
        for chat_id in chat_ids:
            for url in THIRD_RSS_FEEDS:
                feed_messages[url] = await process_third_feed(session, url, third_bot, chat_id)
                if feed_messages[url]:  # 如果有消息，则发送
                    await send_single_message(third_bot, chat_id, feed_messages[url], True)

        # Process FOURTH_RSS_FEEDS for each chat ID using fourth_bot
        for chat_id in chat_ids:
            for url in FOURTH_RSS_FEEDS:
                feed_messages[url] = await process_fourth_feed(session, url, fourth_bot, chat_id)
                if feed_messages[url]:  # 如果有消息，则发送
                    await send_single_message(fourth_bot, chat_id, feed_messages[url], True)


        logging.info("Finished processing all feeds and sent individual messages.")

if __name__ == "__main__":
    asyncio.run(main())
