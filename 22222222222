import asyncio
import aiohttp
import logging
import json
import os
import re
from datetime import datetime
from feedparser import parse
from telegram import Bot
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from dotenv import load_dotenv
from aiohttp import ClientTimeout

# 加载环境变量
load_dotenv()

# 配置RSS源
import asyncio
import aiohttp
import logging
import json
import os
import re
from datetime import datetime
from feedparser import parse
from telegram import Bot
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from dotenv import load_dotenv
from aiohttp import ClientTimeout

# 加载环境变量
load_dotenv()

# 配置RSS源
RSS_FEEDS = [   
   # 'https://blog.090227.xyz/atom.xml',
   # 'https://www.freedidi.com/feed',
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCvijahEyGtvMpmMHBu4FS2w', # 零度解说
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UC96OvMh0Mb_3NmuE8Dpu7Gg', # 搞机零距离
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCQoagx4VHBw3HkAyzvKEEBA', # 科技共享
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCbCCUH8S3yhlm7__rhxR2QQ', # 不良林
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCMtXiCoKFrc2ovAGc1eywDg', # 一休
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCii04BCvYIdQvshrdNDAcww', # 悟空的日常
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCJMEiNh1HvpopPU3n9vJsMQ', # 理科男士
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCYjB6uufPeHSwuHs8wovLjg', # 中指通
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCSs4A6HYKmHA2MG_0z-F0xw', # 李永乐老师
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCZDgXi7VpKhBJxsPuZcBpgA', # 可恩KeEn
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCxukdnZiXnTFvjF5B5dvJ5w', # 甬哥侃侃侃ygkkk
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCUfT9BAofYBKUTiEVrgYGZw', # 科技分享
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UC51FT5EeNPiiQzatlA2RlRA', # 乌客wuke
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCDD8WJ7Il3zWBgEYBUtc9xQ', # jack stone
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCWurUlxgm7YJPPggDz9YJjw', # 一瓶奶油
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCvENMyIFurJi_SrnbnbyiZw', # 酷友社
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCmhbF9emhHa-oZPiBfcLFaQ', # WenWeekly
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UC3BNSKOaphlEoK4L7QTlpbA', # 中外观察
]

SECOND_RSS_FEEDS = [
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCUNciDq-y6I6lEQPeoP-R5A', # 苏恒观察
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCXkOTZJ743JgVhJWmNV8F3Q', # 寒國人
    'https://www.youtube.com/feeds/videos.xml?channel_id=UC2r2LPbOUssIa02EbOIm7NA', # 星球熱點
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCF-Q1Zwyn9681F7du8DMAWg', # 謝宗桓-老謝來了
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCOSmkVK2xsihzKXQgiXPS4w', # 历史哥
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCSYBgX9pWGiUAcBxjnj6JCQ', # 郭正亮頻道
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCNiJNzSkfumLB7bYtXcIEmg', # 真的很博通
 #   'https://www.youtube.com/feeds/videos.xml?channel_id=UCG_gH6S-2ZUOtEw27uIS_QA', # 7Car小七車觀點
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCJ5rBA0z4WFGtUTS83sAb_A', # POP Radio聯播網
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCQeRaTukNYft1_6AZPACnog', # Asmongold TV
    'https://rss.penggan.us.kg/rss/4734eed5ffb55689bfe8ebc4f55e63bd_chinese_simplified', # Asmongold TV
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCN0eCImZY6_OiJbo8cy5bLw', # 屈機TV
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCb3TZ4SD_Ys3j4z0-8o6auA', # BBC News 中文
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCiwt1aanVMoPYUt_CQYCPQg', # 全球大視野
    'https://www.youtube.com/feeds/videos.xml?channel_id=UC000Jn3HGeQSwBuX_cLDK8Q', # 我是柳傑克
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCQFEBaHCJrHu2hzDA_69WQg', # 国漫说
    'https://www.youtube.com/feeds/videos.xml?channel_id=UChJ8YKw6E1rjFHVS9vovrZw', # BNE TV - 新西兰中文国际频道
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCXk0rwHPG9eGV8SaF2p8KUQ', # 烏鴉笑笑

# 影视
    'https://www.youtube.com/feeds/videos.xml?channel_id=UC7Xeh7thVIgs_qfTlwC-dag', # Marc TV
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCqWNOHjgfL8ADEdXGznzwUw', # 悦耳音乐酱
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCCD14H7fJQl3UZNWhYMG3Mg', # 温城鲤
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCQO2T82PiHCYbqmCQ6QO6lw', # 月亮說
   # 'https://www.youtube.com/feeds/videos.xml?channel_id=UCKyDmY3R_xGKz8IjvbijiHA', # 珊珊追剧社
    'https://www.youtube.com/feeds/videos.xml?channel_id=UClyVC2wh_2fQhU0hPdXA4rw', # 热门古风
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UC1ISajIKfRN359MMmtckUTg', # Taiwanese Pop Mix
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCQFyMGc6h30NMCd6HCk0ZPA', # 哔哩哔哩动画
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCQatgKoA7lylp_UzvsLCgcw', # 腾讯视频
  #  'https://www.youtube.com/feeds/videos.xml?channel_id=UCUhpu5MJQ_bjPkXO00jyxsw', # 爱奇艺
    'https://www.youtube.com/feeds/videos.xml?channel_id=UCHW6W9g2TJL2_Lf7GfoI5kg', # 电影放映厅
]

# 文件路径配置
script_dir = os.path.dirname(os.path.abspath(__file__))
RSS_STATUS_FILE = os.path.join(script_dir, 'rss2.json')
log_path = os.path.join(script_dir, 'rss2.log')

# 日志配置
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_path),
        logging.StreamHandler()
    ]
)

def load_rss_status():
    """加载RSS处理状态"""
    try:
        with open(RSS_STATUS_FILE, 'r') as f:
            return json.loads(f.read())
    except FileNotFoundError:
        return {}
    except json.JSONDecodeError:
        return {}

def save_rss_status(status):
    """保存RSS处理状态"""
    with open(RSS_STATUS_FILE, 'w') as f:
        json.dump(status, f, indent=2, ensure_ascii=False)

def parse_datetime(pub_date):
    """解析日期时间"""
    try:
        return datetime(*pub_date[:6]) if pub_date else datetime.now()
    except TypeError:
        return datetime.now()

def prepare_content(text):
    """处理文本内容为Markdown V2安全格式"""
    # 移除HTML标签
    clean_text = re.sub(r'<[^>]+>', '', text)
    # 完整转义Markdown特殊字符
    return escape_markdown(clean_text, version=2)

def prepare_url(url):
    """处理URL为Markdown V2安全格式"""
    # 转义URL中的特殊字符（主要处理括号）
    return url.replace('(', '\\(').replace(')', '\\)')

async def process_feed(session, feed_url, status, bot, chat_ids, max_retries=3):
    """处理单个RSS源"""
    for attempt in range(max_retries):
        try:
            async with session.get(feed_url, timeout=30) as response:
                if response.status != 200:
                    logging.warning(f"请求失败: {feed_url} 状态码 {response.status}")
                    return

                feed = parse(await response.text())
                if not feed.entries:
                    logging.warning(f"无效的RSS源: {feed_url}")
                    return

                # 处理源信息
                feed_title = prepare_content(feed.feed.get('title', '未知来源'))
                entries = []
                
                # 解析条目
                for entry in feed.entries:
                    try:
                        pub_date = parse_datetime(entry.get('published_parsed'))
                        entries.append({
                            'guid': entry.get('id', entry.link),
                            'pubdate': pub_date,
                            'title': prepare_content(entry.title),
                            'link': prepare_url(entry.link)  # 处理URL转义
                        })
                    except Exception as e:
                        logging.warning(f"条目解析失败: {e}")
                        continue

                # 按时间排序
                entries.sort(key=lambda x: x['pubdate'], reverse=True)
                
                # 获取上次状态
                last_status = status.get(feed_url, {})
                last_guid = last_status.get('guid')
                last_date = datetime.fromisoformat(last_status['pubdate']) if 'pubdate' in last_status else None

                # 筛选新条目
                new_entries = []
                for entry in entries:
                    if entry['guid'] == last_guid or (last_date and entry['pubdate'] <= last_date):
                        break
                    new_entries.append(entry)

                # 发送更新通知
                if new_entries:
                    # 构建Markdown消息
                    message_lines = [
                        f"*{feed_title}*",
                        f"📢 发现{len(new_entries)}条更新",
                        "="*30
                    ]
                    
                    for idx, entry in enumerate(reversed(new_entries), 1):
                        message_lines.append(
                            f"{idx}\\. [{entry['title']}]({entry['link']})"
                        )

                    # 发送到所有指定聊天
                    for chat_id in chat_ids:
                        await bot.send_message(
                            chat_id=chat_id,
                            text="\n".join(message_lines),
                            parse_mode=ParseMode.MARKDOWN_V2,
                            disable_web_page_preview=True
                        )
                        await asyncio.sleep(1)  # 避免速率限制

                    # 更新状态
                    status[feed_url] = {
                        'guid': entries[0]['guid'],
                        'pubdate': entries[0]['pubdate'].isoformat()
                    }
                    save_rss_status(status)
                return

        except Exception as e:
            logging.error(f"处理源时发生错误 {feed_url} (尝试 {attempt+1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                await asyncio.sleep(5 * (attempt + 1))

    logging.error(f"处理源 {feed_url} 失败，已达到最大重试次数")

async def process_feed_with_semaphore(semaphore, session, feed_url, status, bot, chat_ids):
    async with semaphore:
        await process_feed(session, feed_url, status, bot, chat_ids)

async def main():
    """主函数"""
    # 初始化配置
    RSS_TOKEN = os.getenv("RSS_TOKEN")
    YOUTUBE_RSS = os.getenv("YOUTUBE_RSS")
    CHAT_IDS = os.getenv("TELEGRAM_CHAT_ID", "").split(",")

    if not RSS_TOKEN or not YOUTUBE_RSS:
        logging.error("缺少机器人Token配置")
        return

    # 初始化机器人
    main_bot = Bot(token=RSS_TOKEN)
    second_bot = Bot(token=YOUTUBE_RSS)
    status = load_rss_status()

    # 创建带并发限制的HTTP会话
    semaphore = asyncio.Semaphore(5)
    timeout = ClientTimeout(total=60)
    
    async with aiohttp.ClientSession(
        connector=aiohttp.TCPConnector(limit=100),
        timeout=timeout
    ) as session:
        tasks = []
        
        # 添加主RSS源任务
        for feed in RSS_FEEDS:
            tasks.append(
                process_feed_with_semaphore(semaphore, session, feed, status, main_bot, CHAT_IDS)
            )
            await asyncio.sleep(0.5)
        
        # 添加次要RSS源任务
        for feed in SECOND_RSS_FEEDS:
            tasks.append(
                process_feed_with_semaphore(semaphore, session, feed, status, second_bot, CHAT_IDS)
            )
            await asyncio.sleep(0.5)
        
        await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(main())

# 文件路径配置
script_dir = os.path.dirname(os.path.abspath(__file__))
RSS_STATUS_FILE = os.path.join(script_dir, 'rss2.json')
log_path = os.path.join(script_dir, 'rss2.log')

# 日志配置
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_path),
        logging.StreamHandler()
    ]
)

def load_rss_status():
    """加载RSS处理状态"""
    try:
        with open(RSS_STATUS_FILE, 'r') as f:
            return json.loads(f.read())
    except FileNotFoundError:
        return {}
    except json.JSONDecodeError:
        return {}

def save_rss_status(status):
    """保存RSS处理状态"""
    with open(RSS_STATUS_FILE, 'w') as f:
        json.dump(status, f, indent=2, ensure_ascii=False)

def parse_datetime(pub_date):
    """解析日期时间"""
    try:
        return datetime(*pub_date[:6]) if pub_date else datetime.now()
    except TypeError:
        return datetime.now()

def prepare_content(text):
    """处理文本内容为Markdown V2安全格式"""
    # 移除HTML标签
    clean_text = re.sub(r'<[^>]+>', '', text)
    # 完整转义Markdown特殊字符
    return escape_markdown(clean_text, version=2)

def prepare_url(url):
    """处理URL为Markdown V2安全格式"""
    # 转义URL中的特殊字符（主要处理括号）
    return url.replace('(', '\\(').replace(')', '\\)')

async def process_feed(session, feed_url, status, bot, chat_ids, max_retries=3):
    """处理单个RSS源"""
    for attempt in range(max_retries):
        try:
            async with session.get(feed_url, timeout=30) as response:
                if response.status != 200:
                    logging.warning(f"请求失败: {feed_url} 状态码 {response.status}")
                    return

                feed = parse(await response.text())
                if not feed.entries:
                    logging.warning(f"无效的RSS源: {feed_url}")
                    return

                # 处理源信息
                feed_title = prepare_content(feed.feed.get('title', '未知来源'))
                entries = []
                
                # 解析条目
                for entry in feed.entries:
                    try:
                        pub_date = parse_datetime(entry.get('published_parsed'))
                        entries.append({
                            'guid': entry.get('id', entry.link),
                            'pubdate': pub_date,
                            'title': prepare_content(entry.title),
                            'link': prepare_url(entry.link)  # 处理URL转义
                        })
                    except Exception as e:
                        logging.warning(f"条目解析失败: {e}")
                        continue

                # 按时间排序
                entries.sort(key=lambda x: x['pubdate'], reverse=True)
                
                # 获取上次状态
                last_status = status.get(feed_url, {})
                last_guid = last_status.get('guid')
                last_date = datetime.fromisoformat(last_status['pubdate']) if 'pubdate' in last_status else None

                # 筛选新条目
                new_entries = []
                for entry in entries:
                    if entry['guid'] == last_guid or (last_date and entry['pubdate'] <= last_date):
                        break
                    new_entries.append(entry)

                # 发送更新通知
                if new_entries:
                    # 构建Markdown消息
                    message_lines = [
                        f"*{feed_title}*",
                        f"📢 发现{len(new_entries)}条更新",
                        "="*30
                    ]
                    
                    for idx, entry in enumerate(reversed(new_entries), 1):
                        message_lines.append(
                            f"{idx}\\. [{entry['title']}]({entry['link']})"
                        )

                    # 发送到所有指定聊天
                    for chat_id in chat_ids:
                        await bot.send_message(
                            chat_id=chat_id,
                            text="\n".join(message_lines),
                            parse_mode=ParseMode.MARKDOWN_V2,
                            disable_web_page_preview=True
                        )
                        await asyncio.sleep(1)  # 避免速率限制

                    # 更新状态
                    status[feed_url] = {
                        'guid': entries[0]['guid'],
                        'pubdate': entries[0]['pubdate'].isoformat()
                    }
                    save_rss_status(status)
                return

        except Exception as e:
            logging.error(f"处理源时发生错误 {feed_url} (尝试 {attempt+1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                await asyncio.sleep(5 * (attempt + 1))

    logging.error(f"处理源 {feed_url} 失败，已达到最大重试次数")

async def process_feed_with_semaphore(semaphore, session, feed_url, status, bot, chat_ids):
    async with semaphore:
        await process_feed(session, feed_url, status, bot, chat_ids)

async def main():
    """主函数"""
    # 初始化配置
    RSS_TOKEN = os.getenv("RSS_TOKEN")
    YOUTUBE_RSS = os.getenv("YOUTUBE_RSS")
    CHAT_IDS = os.getenv("TELEGRAM_CHAT_ID", "").split(",")

    if not RSS_TOKEN or not YOUTUBE_RSS:
        logging.error("缺少机器人Token配置")
        return

    # 初始化机器人
    main_bot = Bot(token=RSS_TOKEN)
    second_bot = Bot(token=YOUTUBE_RSS)
    status = load_rss_status()

    # 创建带并发限制的HTTP会话
    semaphore = asyncio.Semaphore(5)
    timeout = ClientTimeout(total=60)
    
    async with aiohttp.ClientSession(
        connector=aiohttp.TCPConnector(limit=100),
        timeout=timeout
    ) as session:
        tasks = []
        
        # 添加主RSS源任务
        for feed in RSS_FEEDS:
            tasks.append(
                process_feed_with_semaphore(semaphore, session, feed, status, main_bot, CHAT_IDS)
            )
            await asyncio.sleep(0.5)
        
        # 添加次要RSS源任务
        for feed in SECOND_RSS_FEEDS:
            tasks.append(
                process_feed_with_semaphore(semaphore, session, feed, status, second_bot, CHAT_IDS)
            )
            await asyncio.sleep(0.5)
        
        await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(main())